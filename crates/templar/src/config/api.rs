use std::io::Write;
use std::path::Path;

use super::config::Rule;
use anyhow::Result;
// macro use
use lua_export::*;
use rlua;
use rlua::prelude::*;
use rlua::ExternalResult;

// TODO: Move everything here into the lua_export crate / automate using the LUA_FUNCTIONS const
macro_rules! set_lua_functions {
    (
        $lua_context:expr, $(
            $name:literal = $value:expr
        ),*
    )
    => {
        $(
            let function = $lua_context.create_function($value)?;
            let context =  $lua_context.globals();
            context.set($name, function)?;
        )*
    }
}

pub fn register_lua_api(lua: &Lua) -> Result<()> {
    lua.context(|lua_context| {
        set_lua_functions!(
            lua_context,
            "print_rule" = |_, x| lua_functions::print_rule(x).to_lua_err(),
            "_create_default_rule" = |_, ()| lua_functions::_create_default_rule().to_lua_err()
        );
        LuaResult::Ok(())
    })?;
    Ok(())
}

pub fn gen_lua_wrapper(path: impl AsRef<Path>) -> Result<()> {
    let mut file = std::fs::File::create(path)?;
    file.write("-- This file is generated by Templar. Do not edit it manually.\n".as_bytes())?;
    file.write("\n".as_bytes())?;
    file.write("local M = {}\n".as_bytes())?;
    for function in lua_functions::LUA_FUNCTIONS {
        file.write(function.as_bytes())?;
    }
    file.write("\n".as_bytes())?;
    file.write("return M\n".as_bytes())?;
    Ok(())
}

#[lua_export_mod]
mod lua_functions {
    use super::*;

    #[lua_export]
    pub(super) fn print_rule(lua_rule: Rule) -> Result<()> {
        dbg!(lua_rule);
        Ok(())
    }

    #[lua_export]
    pub(super) fn _create_default_rule() -> Result<Rule> {
        dbg!(Rule::default());
        Ok(Rule::default())
    }
}
